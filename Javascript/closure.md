# 클로저

함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 호출이 끝난 뒤 관련 변수를 참조할 수 없는 이유가 이것이다.
자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지된다.

그런데 호출이 끝난 뒤에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 이때는 이 중첩 함수의 `[[environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다.

= 도달 가능한 상태라는 것이다.

이렇게 사용되는 중첩 함수를 **클로저**라고 부른다.

**<span style = "color: rgb(255, 54, 104)">클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다. </span>**

텍스트 설명으로만 보면 백날 봐도 이해하기 힘들어서 예제를 가져왔다.(긁어왔다)

```js
const x = 1;

// 1
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  }; // 2

  return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는
//실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // 3
innerFunc(); // 4 output : 10
```

이 예제에서, outer 함수를 호출(3) 하면 outer 함수는 중첩 함수 inner를 반환하고, 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다. **이때 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다!!**

outer가 스택에서 제거 되었으니 당연히 outer 함수 안의 변수 x의 값도 사라질 것 같지만, 이 함수의 결과는 10이다.
`innerFunc`의 `[[environment]]`에 `outer()` 호출 시 만들어지는 렉시컬 환경 정보가 저장되었기 때문이다.

#### 왜 outer의 렉시컬 환경이 소멸하지 않지?

- outer의 렉시컬 환경은 inner 함수의 `[[environment]]` 내부 슬록에 의해 참조되고 있고, inner 함수는 전역 변수 innerFunc에 의해 참조되고 있기 때문에 가비지 컬렉션의 대상이 되지 않기 때문이다.

🎈 간단히 말하면 innerFunc는 outer()가 반환한 값(inner)을 가지고 있으니, innerFunc()을 호출하게 되면 outer함수에서 리턴된 inner 함수를 호출하는 것과 같다. 여기서 x의 값은 inner 함수의 상위 외부 렉시컬 환경에서 가져오기 때문에 10이 된다.

> 이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.

클로저의 개념은 이제 알겠거든? 근데 어디에 쓰일 수 있는 거지?

## 클로저의 활용

> 클로저는 **상태를 안전하게 변경하고 유지하기 위해** 사용된다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 **상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용**한다!

책에서는 예시로 카운트 함수로 들었다.

```js
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1씩 증가 시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

좋지 않은 코드다. 🙄
카운트 상태를 전역 변수를 통해 관리하고 있기 때문에 언제든지 누구나 접근할 수 있고, 변경할 수도 있다.이것은 의도치 않게 상태가 변경될 수도 있다는 것을 의미한다.

따라서 카운트 상태를 안전하게 변경하고 유지하기 위해서는 `increase` 함수만이 `num` 변수를 참조하고 변경할 수 있게 하는 것이 바람직!

```js
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;
  // 클로저
  return function () {
    //카운트를 1씩 증가시킨다
    return ++num;
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 코드가 실행되면 즉시 실행 함수가 호출되고 즉시 실행 함수가 반환한 함수가 `increase`에 할당된다. `increase` 변수에 할당된 함수는 자신이 정의된 위치의 상위 스코프의 렉시컬 환경을 기억하는 클로저이다.

즉시 실행함수는 한 번만 실행되기 때문에 `increase`가 호출 될 때마다 `num` 변수가 초기화될 일은 없을 것이다. 또한 `num` 변수는 외부에서 직접 접근할 수 없는 은닉된 변수이므로 더 안정적인 프로그래밍이 가능하다.

### But 굳이 프라이빗 환경을 위해 클로저를 작성할 필요는 없다

```js
class Counter {
  #count = 0;
  increase() {
    this.#count++;
    console.log(this.#count);
  }
}

const counter = new Counter();
counter.increase();
```

실제 현업에서는 클로저를 이용한 정보 은닉보다는 클래스의 프라이빗 필드를 활용한다고 한다. 하지만 클로저를 실무에서 마주하게 될 수도 있으니 알아두면 좋을 듯?
