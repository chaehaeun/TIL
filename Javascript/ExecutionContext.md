# 실행 컨텍스트

식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘

## ✔ 소스코드의 네가지 타입

#### ◼ 전역 코드

전역에 존재하는 소스코드. 전역 함수, 클래스 등의 내부 코드는 포함되지 않음

#### ◼ 함수 코드

함수 내부에 존재하는 소스코드. 함수 내부의 중첩함수, 클래스등은 포함되지 않음

#### ◼ eval 코드

빌트인 전역 함수 eval 함수에 인수로 전달되어 실행되는 소스코드(나중에 제대로 공부할 것)

#### ◼ 모듈 코드

모듈 내부에 존재하는 소스코드. 위의 내용들처럼 내부 코드는 포함되지 않는다.

## ✔ 소스코드의 평가와 실행

자바스크립트 엔진은 소스 코드를 2개의 과정, **즉 '소스코드의 평가'와 '소스코드의 실행' 과정으로 나누어 처리한다.**

▶ 소스코드 평가

1. 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행
2. 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드**텍스트**)에 등록한다.

▶ 소스코드 실행

3. 선언문을 제외한 소스코드가 순차적으로 실행됨**(런타임 시작)**
4. 소스코드 실행에 필요한 정보(변수나 함수)의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해 취득.
5. 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.

요는 평가 과정에서 **선언문만** 스윽 읽고 그 정보를 실행 컨텍스트 스코프에 저장해놓고, <br/>
실행 과정(런타임)에서 필요한 정보들을 스코프에서 검색해서 가져온다.<br/> 그리고 이 과정에서 변수의 값이 변동이나 코드의 실행 결과가 나오면, 이것들을 다시 스코프에 저장한다는 말인 것 같다.

조금 더 자세하게 풀어보자!

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 전역 함수 선언
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

1. **전역 코드 평가.** 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행된다. 생성된 변수와 함수를 전역 스코프에 등록한다.

2. **전역 코드 실행.** 런타임이 시작되어 전역 코드가 순차적으로 실행된다. 이때 전역 변수에 값이 할당되고(x,y) 함수(foo(100))가 호출된다. **함수가 호출되면 전역 코드 실행을 잠깐 멈추고 함수 내부로 진입한다.**

3. **함수 코드 평가.** 함수 내부 문들을 실행하기 앞서 매개변수와 지역 변수 선언문이 먼저 실행된다. 생성된 매/지 는 지역 스코프에 등록된다.

4. **함수 코드 실행.** 런타임이 시작되고 함수 코드가 순차적으로 실행된다. 함수 코드 실행 과정이 종료 되면 함수 호출 이전으로 되돌아가 전역 코드를 계속한다.

> 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고, 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.

## ✔ 실행 컨텍스트 스택

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

![](https://velog.velcdn.com/images/chaehe_3210/post/75301a04-926e-44e9-a767-637b56f0c476/image.png)
스택은 이전에 정리한 글이 있으니 넘어간다.
